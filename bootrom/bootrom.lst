
bootrom.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <Reset_Handler>:
/*----------------------------------------------------------------------------
 * boot_mode: Read GPIO0[1:0] to determine boot mode
 *----------------------------------------------------------------------------*/
boot_mode:
    /* Configure GPIO_0[0] and GPIO_0[1] as inputs */
    ldr     r0, =GPIO0_OUTENSET
   0:	4881      	ldr	r0, [pc, #516]	; (208 <boot_fail+0x2>)
    ldr     r1, =GPIO0_ALTFUNC
   2:	4982      	ldr	r1, [pc, #520]	; (20c <boot_fail+0x6>)
    ldr     r2, =0xFFFFFFFC         /* All pins output except [1:0] */
   4:	4a82      	ldr	r2, [pc, #520]	; (210 <boot_fail+0xa>)
    str     r2, [r0]
   6:	6002      	str	r2, [r0, #0]
    str     r2, [r1]
   8:	600a      	str	r2, [r1, #0]

    /* Read GPIO0 data register */
    ldr     r0, =GPIO0_DATA_REG
   a:	4882      	ldr	r0, [pc, #520]	; (214 <boot_fail+0xe>)
    ldr     r1, [r0]
   c:	6801      	ldr	r1, [r0, #0]
    movs    r2, #0x03               /* Mask bits [1:0] */
   e:	2203      	movs	r2, #3
    ands    r1, r2
  10:	4011      	ands	r1, r2

    /* Branch based on boot mode */
    cmp     r1, #0
  12:	2900      	cmp	r1, #0
    beq     boot_flash              /* 00: QSPI Flash boot */
  14:	d006      	beq.n	24 <boot_flash>

    cmp     r1, #1
  16:	2901      	cmp	r1, #1
    beq     boot_uart               /* 01: UART boot */
  18:	d00c      	beq.n	34 <boot_uart>

    cmp     r1, #2
  1a:	2902      	cmp	r1, #2
    beq     boot_swd                /* 10: SWD debug boot */
  1c:	d008      	beq.n	30 <boot_swd>

    cmp     r1, #3
  1e:	2903      	cmp	r1, #3
    beq     boot_sdio               /* 11: SDIO boot */
  20:	d046      	beq.n	b0 <boot_sdio>

    b       boot_flash              /* Default: Flash boot */
  22:	e7ff      	b.n	24 <boot_flash>

00000024 <boot_flash>:

/*============================================================================
 * boot_flash: Boot from QSPI XIP Flash
 *============================================================================*/
boot_flash:
    ldr     r0, =QSPI_XIP_BASE
  24:	487c      	ldr	r0, [pc, #496]	; (218 <boot_fail+0x12>)
    ldr     r1, [r0]                /* Load MSP from flash */
  26:	6801      	ldr	r1, [r0, #0]
    ldr     r0, [r0, #4]            /* Load Reset vector from flash */
  28:	6840      	ldr	r0, [r0, #4]
    msr     msp, r1
  2a:	f381 8808 	msr	MSP, r1
    bx      r0                      /* Jump to application */
  2e:	4700      	bx	r0

00000030 <boot_swd>:

/*============================================================================
 * boot_swd: Debug boot - halt and wait for debugger
 *============================================================================*/
boot_swd:
    bkpt    #0                      /* Breakpoint for debugger */
  30:	be00      	bkpt	0x0000
    b       boot_swd                /* Loop if no debugger attached */
  32:	e7fd      	b.n	30 <boot_swd>

00000034 <boot_uart>:
 * boot_uart: Boot from UART (receive binary via serial)
 * Protocol: MAGIC(4B) + SIZE(4B) + DATA(SIZE bytes)
 *============================================================================*/
boot_uart:
    /* Configure UART: 115200 baud, 8N1 */
    ldr     r0, =UART_CTRL
  34:	4879      	ldr	r0, [pc, #484]	; (21c <boot_fail+0x16>)
    movs    r4, #0
  36:	2400      	movs	r4, #0
    str     r4, [r0]                /* Disable UART */
  38:	6004      	str	r4, [r0, #0]

    ldr     r0, =UART_BAUD
  3a:	4879      	ldr	r0, [pc, #484]	; (220 <boot_fail+0x1a>)
    ldr     r4, =278                /* 32MHz / 115200 ≈ 278 */
  3c:	4c79      	ldr	r4, [pc, #484]	; (224 <boot_fail+0x1e>)
    str     r4, [r0]
  3e:	6004      	str	r4, [r0, #0]

    ldr     r0, =UART_CTRL
  40:	4876      	ldr	r0, [pc, #472]	; (21c <boot_fail+0x16>)
    movs    r4, #0x02               /* Enable RX only */
  42:	2402      	movs	r4, #2
    str     r4, [r0]
  44:	6004      	str	r4, [r0, #0]

    /* Read MAGIC word */
    bl      uart_read_word
  46:	f000 f822 	bl	8e <uart_read_word>
    ldr     r3, =MAGIC_VALUE
  4a:	4b77      	ldr	r3, [pc, #476]	; (228 <boot_fail+0x22>)
    cmp     r5, r3
  4c:	429d      	cmp	r5, r3
    beq     uart_magic_ok
  4e:	d000      	beq.n	52 <uart_magic_ok>
    b       boot_fail
  50:	e0d9      	b.n	206 <boot_fail>

00000052 <uart_magic_ok>:
uart_magic_ok:

    /* Read SIZE word */
    bl      uart_read_word
  52:	f000 f81c 	bl	8e <uart_read_word>
    cmp     r5, #0
  56:	2d00      	cmp	r5, #0
    bne     uart_size_nz
  58:	d100      	bne.n	5c <uart_size_nz>
    b       boot_fail
  5a:	e0d4      	b.n	206 <boot_fail>

0000005c <uart_size_nz>:
uart_size_nz:
    ldr     r4, =MAX_STAGE1_SZ
  5c:	4c73      	ldr	r4, [pc, #460]	; (22c <boot_fail+0x26>)
    cmp     r5, r4
  5e:	42a5      	cmp	r5, r4
    bls     uart_size_ok
  60:	d900      	bls.n	64 <uart_size_ok>
    b       boot_fail
  62:	e0d0      	b.n	206 <boot_fail>

00000064 <uart_size_ok>:
uart_size_ok:

    /* Copy data to SRAM */
    mov     r6, r5                  /* r6 = byte count */
  64:	462e      	mov	r6, r5
    ldr     r7, =SRAM_ADDR          /* r7 = destination */
  66:	4f72      	ldr	r7, [pc, #456]	; (230 <boot_fail+0x2a>)

00000068 <uart_copy_loop>:

uart_copy_loop:
    ldr     r0, =UART_STAT
  68:	4872      	ldr	r0, [pc, #456]	; (234 <boot_fail+0x2e>)

0000006a <uart_wait_rx>:
uart_wait_rx:
    ldr     r4, [r0]
  6a:	6804      	ldr	r4, [r0, #0]
    movs    r3, #0x02               /* RX data available bit */
  6c:	2302      	movs	r3, #2
    tst     r4, r3
  6e:	421c      	tst	r4, r3
    beq     uart_wait_rx
  70:	d0fb      	beq.n	6a <uart_wait_rx>

    ldr     r0, =UART_DATA
  72:	4871      	ldr	r0, [pc, #452]	; (238 <boot_fail+0x32>)
    ldr     r4, [r0]
  74:	6804      	ldr	r4, [r0, #0]
    movs    r3, #0xFF
  76:	23ff      	movs	r3, #255	; 0xff
    ands    r4, r3                  /* Mask to 8 bits */
  78:	401c      	ands	r4, r3
    strb    r4, [r7]                /* Store byte to SRAM */
  7a:	703c      	strb	r4, [r7, #0]
    adds    r7, #1
  7c:	3701      	adds	r7, #1
    subs    r6, #1
  7e:	3e01      	subs	r6, #1
    bne     uart_copy_loop
  80:	d1f2      	bne.n	68 <uart_copy_loop>

    /* Jump to loaded application */
    ldr     r0, =SRAM_ADDR
  82:	486b      	ldr	r0, [pc, #428]	; (230 <boot_fail+0x2a>)
    ldr     r1, [r0]                /* Load MSP */
  84:	6801      	ldr	r1, [r0, #0]
    ldr     r0, [r0, #4]            /* Load Reset vector */
  86:	6840      	ldr	r0, [r0, #4]
    msr     msp, r1
  88:	f381 8808 	msr	MSP, r1
    bx      r0
  8c:	4700      	bx	r0

0000008e <uart_read_word>:

/*----------------------------------------------------------------------------
 * uart_read_word: Read 4 bytes from UART into r5 (big-endian)
 *----------------------------------------------------------------------------*/
uart_read_word:
    push    {lr}
  8e:	b500      	push	{lr}
    movs    r5, #0
  90:	2500      	movs	r5, #0
    movs    r6, #4                  /* 4 bytes to read */
  92:	2604      	movs	r6, #4

00000094 <uart_word_loop>:

uart_word_loop:
    ldr     r0, =UART_STAT
  94:	4867      	ldr	r0, [pc, #412]	; (234 <boot_fail+0x2e>)

00000096 <uart_word_wait>:
uart_word_wait:
    ldr     r4, [r0]
  96:	6804      	ldr	r4, [r0, #0]
    movs    r3, #0x02
  98:	2302      	movs	r3, #2
    tst     r4, r3
  9a:	421c      	tst	r4, r3
    beq     uart_word_wait
  9c:	d0fb      	beq.n	96 <uart_word_wait>

    ldr     r0, =UART_DATA
  9e:	4866      	ldr	r0, [pc, #408]	; (238 <boot_fail+0x32>)
    ldr     r4, [r0]
  a0:	6804      	ldr	r4, [r0, #0]
    movs    r3, #0xFF
  a2:	23ff      	movs	r3, #255	; 0xff
    ands    r4, r3
  a4:	401c      	ands	r4, r3
    lsls    r5, r5, #8
  a6:	022d      	lsls	r5, r5, #8
    orrs    r5, r4
  a8:	4325      	orrs	r5, r4
    subs    r6, #1
  aa:	3e01      	subs	r6, #1
    bne     uart_word_loop
  ac:	d1f2      	bne.n	94 <uart_word_loop>

    pop     {pc}
  ae:	bd00      	pop	{pc}

000000b0 <boot_sdio>:
 *============================================================================*/
boot_sdio:
    /* ---- Step 1: Initialize SDIO PHY ---- */
    /* Set PHY: 1-bit mode, slow clock for init (~400kHz from 50MHz) */
    /* PHY register: bits[7:0]=clock divider, bit[8]=DDR mode */
    ldr     r0, =SDIO_PHY
  b0:	4862      	ldr	r0, [pc, #392]	; (23c <boot_fail+0x36>)
    ldr     r1, =0x0000007F         /* Clock divider = 127 (slow clock) */
  b2:	4963      	ldr	r1, [pc, #396]	; (240 <boot_fail+0x3a>)
    str     r1, [r0]
  b4:	6001      	str	r1, [r0, #0]

    /* Small delay for clock to stabilize */
    ldr     r2, =0x1000
  b6:	4a63      	ldr	r2, [pc, #396]	; (244 <SD_CMD2+0x2>)

000000b8 <sdio_delay1>:
sdio_delay1:
    subs    r2, #1
  b8:	3a01      	subs	r2, #1
    bne     sdio_delay1
  ba:	d1fd      	bne.n	b8 <sdio_delay1>

    /* ---- Step 2: Send CMD0 (GO_IDLE_STATE) ---- */
    ldr     r0, =SDIO_ARG
  bc:	4862      	ldr	r0, [pc, #392]	; (248 <SD_CMD2+0x6>)
    movs    r1, #0
  be:	2100      	movs	r1, #0
    str     r1, [r0]                /* Argument = 0 */
  c0:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
  c2:	4862      	ldr	r0, [pc, #392]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD0
  c4:	4962      	ldr	r1, [pc, #392]	; (250 <SD_CMD2+0xe>)
    str     r1, [r0]
  c6:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
  c8:	f000 f894 	bl	1f4 <sdio_wait_cmd>

    /* Delay after CMD0 */
    ldr     r2, =0x1000
  cc:	4a5d      	ldr	r2, [pc, #372]	; (244 <SD_CMD2+0x2>)

000000ce <sdio_delay2>:
sdio_delay2:
    subs    r2, #1
  ce:	3a01      	subs	r2, #1
    bne     sdio_delay2
  d0:	d1fd      	bne.n	ce <sdio_delay2>

    /* ---- Step 3: Send CMD8 (SEND_IF_COND) ---- */
    /* Argument: 0x000001AA (voltage=2.7-3.6V, check pattern=0xAA) */
    ldr     r0, =SDIO_ARG
  d2:	485d      	ldr	r0, [pc, #372]	; (248 <SD_CMD2+0x6>)
    ldr     r1, =0x000001AA
  d4:	495f      	ldr	r1, [pc, #380]	; (254 <SD_CMD2+0x12>)
    str     r1, [r0]
  d6:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
  d8:	485c      	ldr	r0, [pc, #368]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD8
  da:	495f      	ldr	r1, [pc, #380]	; (258 <SD_CMD2+0x16>)
    str     r1, [r0]
  dc:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
  de:	f000 f889 	bl	1f4 <sdio_wait_cmd>

    /* Check response (should echo back 0x1AA) */
    ldr     r0, =SDIO_ARG
  e2:	4859      	ldr	r0, [pc, #356]	; (248 <SD_CMD2+0x6>)
    ldr     r1, [r0]
  e4:	6801      	ldr	r1, [r0, #0]
    ldr     r2, =0x000001AA
  e6:	4a5b      	ldr	r2, [pc, #364]	; (254 <SD_CMD2+0x12>)
    ands    r1, r2
  e8:	4011      	ands	r1, r2
    cmp     r1, r2
  ea:	4291      	cmp	r1, r2
    beq     sdio_cmd8_ok
  ec:	d000      	beq.n	f0 <sdio_cmd8_ok>
    b       boot_fail               /* Card doesn't support voltage */
  ee:	e08a      	b.n	206 <boot_fail>

000000f0 <sdio_cmd8_ok>:
sdio_cmd8_ok:

    /* ---- Step 4: Send ACMD41 until card is ready ---- */
    movs    r4, #100                /* Max retries */
  f0:	2464      	movs	r4, #100	; 0x64

000000f2 <acmd41_loop>:

acmd41_loop:
    /* Send CMD55 (APP_CMD) first */
    ldr     r0, =SDIO_ARG
  f2:	4855      	ldr	r0, [pc, #340]	; (248 <SD_CMD2+0x6>)
    movs    r1, #0                  /* RCA = 0 during init */
  f4:	2100      	movs	r1, #0
    str     r1, [r0]
  f6:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
  f8:	4854      	ldr	r0, [pc, #336]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD55
  fa:	4958      	ldr	r1, [pc, #352]	; (25c <SD_CMD2+0x1a>)
    str     r1, [r0]
  fc:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
  fe:	f000 f879 	bl	1f4 <sdio_wait_cmd>

    /* Send ACMD41 */
    /* Argument: HCS=1 (High Capacity Support), voltage window */
    ldr     r0, =SDIO_ARG
 102:	4851      	ldr	r0, [pc, #324]	; (248 <SD_CMD2+0x6>)
    ldr     r1, =0x40300000         /* HCS=1, 3.2-3.4V */
 104:	4956      	ldr	r1, [pc, #344]	; (260 <SD_CMD2+0x1e>)
    str     r1, [r0]
 106:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
 108:	4850      	ldr	r0, [pc, #320]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_ACMD41
 10a:	4956      	ldr	r1, [pc, #344]	; (264 <SD_CMD2+0x22>)
    str     r1, [r0]
 10c:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
 10e:	f000 f871 	bl	1f4 <sdio_wait_cmd>

    /* Check if card is ready (busy bit cleared) */
    ldr     r0, =SDIO_ARG           /* Read OCR response */
 112:	484d      	ldr	r0, [pc, #308]	; (248 <SD_CMD2+0x6>)
    ldr     r1, [r0]
 114:	6801      	ldr	r1, [r0, #0]
    movs    r2, #0x80
 116:	2280      	movs	r2, #128	; 0x80
    lsls    r2, r2, #24             /* r2 = 0x80000000 (ready bit) */
 118:	0612      	lsls	r2, r2, #24
    tst     r1, r2
 11a:	4211      	tst	r1, r2
    bne     acmd41_done
 11c:	d106      	bne.n	12c <acmd41_done>

    /* Not ready, retry */
    subs    r4, #1
 11e:	3c01      	subs	r4, #1
    bne     acmd41_retry
 120:	d100      	bne.n	124 <acmd41_retry>
    b       boot_fail               /* Timeout */
 122:	e070      	b.n	206 <boot_fail>

00000124 <acmd41_retry>:
acmd41_retry:

    /* Small delay between retries */
    ldr     r2, =0x2000
 124:	4a50      	ldr	r2, [pc, #320]	; (268 <SD_CMD2+0x26>)

00000126 <acmd41_delay>:
acmd41_delay:
    subs    r2, #1
 126:	3a01      	subs	r2, #1
    bne     acmd41_delay
 128:	d1fd      	bne.n	126 <acmd41_delay>
    b       acmd41_loop
 12a:	e7e2      	b.n	f2 <acmd41_loop>

0000012c <acmd41_done>:

acmd41_done:
    /* Save card capacity type (CCS bit) */
    movs    r2, #0x40
 12c:	2240      	movs	r2, #64	; 0x40
    lsls    r2, r2, #24             /* r2 = 0x40000000 (CCS bit) */
 12e:	0612      	lsls	r2, r2, #24
    tst     r1, r2
 130:	4211      	tst	r1, r2
    bne     sd_hc_card
 132:	d101      	bne.n	138 <sd_hc_card>
    movs    r4, #0                  /* Standard capacity: byte addressing */
 134:	2400      	movs	r4, #0
    b       sd_continue
 136:	e000      	b.n	13a <sd_continue>

00000138 <sd_hc_card>:
sd_hc_card:
    movs    r4, #1                  /* High capacity: block addressing */
 138:	2401      	movs	r4, #1

0000013a <sd_continue>:

sd_continue:
    push    {r4}                    /* Save card type on stack */
 13a:	b410      	push	{r4}

    /* ---- Step 5: Send CMD2 (ALL_SEND_CID) ---- */
    ldr     r0, =SDIO_ARG
 13c:	4842      	ldr	r0, [pc, #264]	; (248 <SD_CMD2+0x6>)
    movs    r1, #0
 13e:	2100      	movs	r1, #0
    str     r1, [r0]
 140:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
 142:	4842      	ldr	r0, [pc, #264]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD2
 144:	4949      	ldr	r1, [pc, #292]	; (26c <SD_CMD2+0x2a>)
    str     r1, [r0]
 146:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
 148:	f000 f854 	bl	1f4 <sdio_wait_cmd>

    /* ---- Step 6: Send CMD3 (SEND_RELATIVE_ADDR) ---- */
    ldr     r0, =SDIO_ARG
 14c:	483e      	ldr	r0, [pc, #248]	; (248 <SD_CMD2+0x6>)
    movs    r1, #0
 14e:	2100      	movs	r1, #0
    str     r1, [r0]
 150:	6001      	str	r1, [r0, #0]

    ldr     r0, =SDIO_CMD
 152:	483e      	ldr	r0, [pc, #248]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD3
 154:	4946      	ldr	r1, [pc, #280]	; (270 <SD_CMD2+0x2e>)
    str     r1, [r0]
 156:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
 158:	f000 f84c 	bl	1f4 <sdio_wait_cmd>

    /* Get RCA from response (bits [31:16]) */
    ldr     r0, =SDIO_ARG
 15c:	483a      	ldr	r0, [pc, #232]	; (248 <SD_CMD2+0x6>)
    ldr     r6, [r0]                /* r6 = RCA in upper 16 bits */
 15e:	6806      	ldr	r6, [r0, #0]
    lsrs    r6, r6, #16
 160:	0c36      	lsrs	r6, r6, #16
    lsls    r6, r6, #16             /* r6 = RCA << 16 */
 162:	0436      	lsls	r6, r6, #16

    /* ---- Step 7: Send CMD7 (SELECT_CARD) ---- */
    ldr     r0, =SDIO_ARG
 164:	4838      	ldr	r0, [pc, #224]	; (248 <SD_CMD2+0x6>)
    str     r6, [r0]                /* Argument = RCA << 16 */
 166:	6006      	str	r6, [r0, #0]

    ldr     r0, =SDIO_CMD
 168:	4838      	ldr	r0, [pc, #224]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD7
 16a:	4942      	ldr	r1, [pc, #264]	; (274 <SD_CMD2+0x32>)
    str     r1, [r0]
 16c:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
 16e:	f000 f841 	bl	1f4 <sdio_wait_cmd>

    /* ---- Switch to faster clock after init ---- */
    ldr     r0, =SDIO_PHY
 172:	4832      	ldr	r0, [pc, #200]	; (23c <boot_fail+0x36>)
    ldr     r1, =0x00000002         /* Fast clock divider */
 174:	4940      	ldr	r1, [pc, #256]	; (278 <SD_CMD2+0x36>)
    str     r1, [r0]
 176:	6001      	str	r1, [r0, #0]
     *   Offset 0: Stack pointer (MSP)
     *   Offset 4: Reset handler address
     *   Offset 8: Image size (in bytes)
     *   Offset 12+: Application code
     */
    pop     {r4}                    /* Restore card type (HC or SC) */
 178:	bc10      	pop	{r4}
    
    ldr     r7, =SRAM_ADDR          /* Destination address */
 17a:	4f2d      	ldr	r7, [pc, #180]	; (230 <boot_fail+0x2a>)
    ldr     r5, =SD_BOOT_SECTOR     /* Start sector */
 17c:	4d3f      	ldr	r5, [pc, #252]	; (27c <SD_CMD2+0x3a>)

    /* Read first sector to get image size */
    bl      sdio_read_sector
 17e:	f000 f823 	bl	1c8 <sdio_read_sector>

    /* Parse header from SRAM */
    ldr     r0, =SRAM_ADDR
 182:	482b      	ldr	r0, [pc, #172]	; (230 <boot_fail+0x2a>)
    ldr     r1, [r0, #8]            /* Image size */
 184:	6881      	ldr	r1, [r0, #8]
    
    /* Validate size */
    cmp     r1, #0
 186:	2900      	cmp	r1, #0
    bne     sdio_size_nz
 188:	d100      	bne.n	18c <sdio_size_nz>
    b       boot_fail
 18a:	e03c      	b.n	206 <boot_fail>

0000018c <sdio_size_nz>:
sdio_size_nz:
    ldr     r2, =MAX_STAGE1_SZ
 18c:	4a27      	ldr	r2, [pc, #156]	; (22c <boot_fail+0x26>)
    cmp     r1, r2
 18e:	4291      	cmp	r1, r2
    bls     sdio_size_ok
 190:	d900      	bls.n	194 <sdio_size_ok>
    b       boot_fail
 192:	e038      	b.n	206 <boot_fail>

00000194 <sdio_size_ok>:
sdio_size_ok:

    /* Calculate remaining sectors to read */
    ldr     r2, =SD_BLOCK_SIZE
 194:	4a3a      	ldr	r2, [pc, #232]	; (280 <SD_CMD2+0x3e>)
    subs    r1, r2                  /* Subtract first sector */
 196:	1a89      	subs	r1, r1, r2
    cmp     r1, #0
 198:	2900      	cmp	r1, #0
    ble     sdio_boot_jump          /* No more sectors needed */
 19a:	dd0f      	ble.n	1bc <sdio_boot_jump>

    /* r1 = remaining bytes, calculate sectors */
    adds    r1, r2
 19c:	1889      	adds	r1, r1, r2
    subs    r1, #1
 19e:	3901      	subs	r1, #1
    lsrs    r1, r1, #9              /* Divide by 512 (sector size) */
 1a0:	0a49      	lsrs	r1, r1, #9

    /* Read remaining sectors */
    adds    r5, #1                  /* Next sector */
 1a2:	3501      	adds	r5, #1
    adds    r7, r2                  /* Next destination (SRAM + 512) */
 1a4:	18bf      	adds	r7, r7, r2

000001a6 <sdio_read_loop>:

sdio_read_loop:
    cmp     r1, #0
 1a6:	2900      	cmp	r1, #0
    beq     sdio_boot_jump
 1a8:	d008      	beq.n	1bc <sdio_boot_jump>
    
    push    {r1}
 1aa:	b402      	push	{r1}
    bl      sdio_read_sector
 1ac:	f000 f80c 	bl	1c8 <sdio_read_sector>
    pop     {r1}
 1b0:	bc02      	pop	{r1}
    
    adds    r5, #1                  /* Next sector */
 1b2:	3501      	adds	r5, #1
    ldr     r2, =SD_BLOCK_SIZE
 1b4:	4a32      	ldr	r2, [pc, #200]	; (280 <SD_CMD2+0x3e>)
    adds    r7, r2                  /* Next destination */
 1b6:	18bf      	adds	r7, r7, r2
    subs    r1, #1
 1b8:	3901      	subs	r1, #1
    b       sdio_read_loop
 1ba:	e7f4      	b.n	1a6 <sdio_read_loop>

000001bc <sdio_boot_jump>:

sdio_boot_jump:
    /* Jump to loaded application */
    ldr     r0, =SRAM_ADDR
 1bc:	481c      	ldr	r0, [pc, #112]	; (230 <boot_fail+0x2a>)
    ldr     r1, [r0]                /* Load MSP */
 1be:	6801      	ldr	r1, [r0, #0]
    ldr     r0, [r0, #4]            /* Load Reset vector */
 1c0:	6840      	ldr	r0, [r0, #4]
    msr     msp, r1
 1c2:	f381 8808 	msr	MSP, r1
    bx      r0
 1c6:	4700      	bx	r0

000001c8 <sdio_read_sector>:
 *           r6 = RCA << 16
 *           r7 = destination address in SRAM
 *   Uses:   r0, r1, r2, r3
 *----------------------------------------------------------------------------*/
sdio_read_sector:
    push    {lr}
 1c8:	b500      	push	{lr}

    /* Set up argument (address) */
    ldr     r0, =SDIO_ARG
 1ca:	481f      	ldr	r0, [pc, #124]	; (248 <SD_CMD2+0x6>)
    cmp     r4, #0
 1cc:	2c00      	cmp	r4, #0
    bne     sdio_hc_addr
 1ce:	d101      	bne.n	1d4 <sdio_hc_addr>
    /* Standard Capacity: byte address = sector * 512 */
    lsls    r1, r5, #9
 1d0:	0269      	lsls	r1, r5, #9
    b       sdio_send_cmd17
 1d2:	e000      	b.n	1d6 <sdio_send_cmd17>

000001d4 <sdio_hc_addr>:
sdio_hc_addr:
    /* High Capacity: sector address */
    mov     r1, r5
 1d4:	4629      	mov	r1, r5

000001d6 <sdio_send_cmd17>:
sdio_send_cmd17:
    str     r1, [r0]
 1d6:	6001      	str	r1, [r0, #0]

    /* Send CMD17 (READ_SINGLE_BLOCK) */
    ldr     r0, =SDIO_CMD
 1d8:	481c      	ldr	r0, [pc, #112]	; (24c <SD_CMD2+0xa>)
    ldr     r1, =SD_CMD17
 1da:	492a      	ldr	r1, [pc, #168]	; (284 <SD_CMD2+0x42>)
    str     r1, [r0]
 1dc:	6001      	str	r1, [r0, #0]
    bl      sdio_wait_cmd
 1de:	f000 f809 	bl	1f4 <sdio_wait_cmd>

    /* Read 512 bytes from FIFO */
    ldr     r0, =SDIO_FIFOA
 1e2:	4829      	ldr	r0, [pc, #164]	; (288 <SD_CMD2+0x46>)
    mov     r1, r7                  /* Destination */
 1e4:	4639      	mov	r1, r7
    ldr     r2, =128                /* 512 bytes / 4 bytes per word = 128 words */
 1e6:	4a29      	ldr	r2, [pc, #164]	; (28c <SD_CMD2+0x4a>)

000001e8 <sdio_fifo_read_loop>:

sdio_fifo_read_loop:
    ldr     r3, [r0]                /* Read word from FIFO */
 1e8:	6803      	ldr	r3, [r0, #0]
    str     r3, [r1]                /* Store to SRAM */
 1ea:	600b      	str	r3, [r1, #0]
    adds    r1, #4
 1ec:	3104      	adds	r1, #4
    subs    r2, #1
 1ee:	3a01      	subs	r2, #1
    bne     sdio_fifo_read_loop
 1f0:	d1fa      	bne.n	1e8 <sdio_fifo_read_loop>

    pop     {pc}
 1f2:	bd00      	pop	{pc}

000001f4 <sdio_wait_cmd>:
/*----------------------------------------------------------------------------
 * sdio_wait_cmd: Wait for SDIO command to complete
 *   Checks CMD register bit 15 (busy) and bit 14 (error)
 *----------------------------------------------------------------------------*/
sdio_wait_cmd:
    ldr     r0, =SDIO_CMD
 1f4:	4815      	ldr	r0, [pc, #84]	; (24c <SD_CMD2+0xa>)

000001f6 <sdio_wait_loop>:
sdio_wait_loop:
    ldr     r1, [r0]
 1f6:	6801      	ldr	r1, [r0, #0]
    
    /* Check for error (bit 15) */
    ldr     r2, =0x8000             /* ERR_BIT = 15 */
 1f8:	4a0c      	ldr	r2, [pc, #48]	; (22c <boot_fail+0x26>)
    tst     r1, r2
 1fa:	4211      	tst	r1, r2
    bne     boot_fail
 1fc:	d103      	bne.n	206 <boot_fail>
    
    /* Check if busy (command in progress) */
    /* The CMD register indicates busy when command is processing */
    ldr     r2, =0x4000             /* Check done bit or similar */
 1fe:	4a24      	ldr	r2, [pc, #144]	; (290 <SD_CMD2+0x4e>)
    tst     r1, r2
 200:	4211      	tst	r1, r2
    beq     sdio_wait_loop          /* Still busy */
 202:	d0f8      	beq.n	1f6 <sdio_wait_loop>
    
    bx      lr
 204:	4770      	bx	lr

00000206 <boot_fail>:

/*============================================================================
 * boot_fail: Infinite loop on error
 *============================================================================*/
boot_fail:
    b       boot_fail
 206:	e7fe      	b.n	206 <boot_fail>
    ldr     r0, =GPIO0_OUTENSET
 208:	40010010 	.word	0x40010010
    ldr     r1, =GPIO0_ALTFUNC
 20c:	40010018 	.word	0x40010018
    ldr     r2, =0xFFFFFFFC         /* All pins output except [1:0] */
 210:	fffffffc 	.word	0xfffffffc
    ldr     r0, =GPIO0_DATA_REG
 214:	40010000 	.word	0x40010000
    ldr     r0, =QSPI_XIP_BASE
 218:	10000000 	.word	0x10000000
    ldr     r0, =UART_CTRL
 21c:	40004008 	.word	0x40004008
    ldr     r0, =UART_BAUD
 220:	40004010 	.word	0x40004010
    ldr     r4, =278                /* 32MHz / 115200 ≈ 278 */
 224:	00000116 	.word	0x00000116
    ldr     r3, =MAGIC_VALUE
 228:	f1f1f1f1 	.word	0xf1f1f1f1
    ldr     r4, =MAX_STAGE1_SZ
 22c:	00008000 	.word	0x00008000
    ldr     r7, =SRAM_ADDR          /* r7 = destination */
 230:	20000000 	.word	0x20000000
    ldr     r0, =UART_STAT
 234:	40004004 	.word	0x40004004
    ldr     r0, =UART_DATA
 238:	40004000 	.word	0x40004000
    ldr     r0, =SDIO_PHY
 23c:	48000010 	.word	0x48000010
    ldr     r1, =0x0000007F         /* Clock divider = 127 (slow clock) */
 240:	0000007f 	.word	0x0000007f
    ldr     r2, =0x1000
 244:	00001000 	.word	0x00001000
    ldr     r0, =SDIO_ARG
 248:	48000004 	.word	0x48000004
    ldr     r0, =SDIO_CMD
 24c:	48000000 	.word	0x48000000
    ldr     r1, =SD_CMD0
 250:	00000040 	.word	0x00000040
    ldr     r1, =0x000001AA
 254:	000001aa 	.word	0x000001aa
    ldr     r1, =SD_CMD8
 258:	00000148 	.word	0x00000148
    ldr     r1, =SD_CMD55
 25c:	00000177 	.word	0x00000177
    ldr     r1, =0x40300000         /* HCS=1, 3.2-3.4V */
 260:	40300000 	.word	0x40300000
    ldr     r1, =SD_ACMD41
 264:	00000169 	.word	0x00000169
    ldr     r2, =0x2000
 268:	00002000 	.word	0x00002000
    ldr     r1, =SD_CMD2
 26c:	00000242 	.word	0x00000242
    ldr     r1, =SD_CMD3
 270:	00000143 	.word	0x00000143
    ldr     r1, =SD_CMD7
 274:	00000147 	.word	0x00000147
    ldr     r1, =0x00000002         /* Fast clock divider */
 278:	00000002 	.word	0x00000002
    ldr     r5, =SD_BOOT_SECTOR     /* Start sector */
 27c:	00000001 	.word	0x00000001
    ldr     r2, =SD_BLOCK_SIZE
 280:	00000200 	.word	0x00000200
    ldr     r1, =SD_CMD17
 284:	00000951 	.word	0x00000951
    ldr     r0, =SDIO_FIFOA
 288:	48000008 	.word	0x48000008
    ldr     r2, =128                /* 512 bytes / 4 bytes per word = 128 words */
 28c:	00000080 	.word	0x00000080
    ldr     r2, =0x4000             /* Check done bit or similar */
 290:	00004000 	.word	0x00004000
